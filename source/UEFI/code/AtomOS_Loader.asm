format binary
use16
start:

	;----- Подготавливаем сегментные регистры ------
	cli
	mov ax, 1000h
	mov es, ax
	mov ds, ax
	xor sp, sp
	;mov ss, ax
	sti
	;----- Открываем линию A20 ---------------------
	A20_UNLOCK:
		in al, 0x92
		;test al, 10b    ; Проверяем, открыта ли линия
		;jnz .exit       ; Если да, то просто продолжаем работу загрузчика
		or al, 10b      ; Иначе устанавливаем необходимый бит
		;and al, 0xFE
		out 0x92, al    ; Применяем изменения
		.exit:
	   ;----- Отключаем маскируемые прерывания --------
		cli
	   ;----- Отключаем немаскируемые прерывания -----
	   mov al, 8Fh
	   out 70h, al
	   in al, 71h
	   ;-----------------------------------------------
	    
   ;----- Переводим процессор в защищённый режим --
   lgdt [GDTR_DATA]     ; Загружаем в регистр GDTR данные из GTDR_DATA
   mov eax, cr0         ; Сохраняем состояние регистра CR0 в регистр 
   or al, 1b            ; Устанавливаем PE (Protection Enable) бит
   mov cr0, eax         ; Переносим изменения в регистр CR0

	jmp fword 08h:ProtectedMode
	;jmp dword ProtectedMode
	;jmp $

	;align 8
	;===== Global Descriptor Table =====
	GDT:
	;     ___________________Content(Segment Descriptor)_____________________________
	;   |  Base  |   Flags   |  Limit   |       Access Byte       |   Base   | Limit |
	;   |        | G D X U   |          | P  DPL S  E  DC  RW  A  |          |       |
	;   | 0x00   | 0 0 0 0   |  0h      | 0  00  0  0  0   0   0  | 0x000000 | 0000h | 1-я запись всегда равна NULL
	;   | 0x00   | 1 1 0 0   |  0h      | 1  00  1  1  0   1   0  | 0x000000 | 0FFFh | 2-я запись - сегмент кода ОС
	;   | 0x00   | 1 1 0 0   |  0h      | 1  00  1  0  0   1   0  | 0x000000 | 0FFFh | 3-я запись - сегмент данных ОС
	;   | 0x00   | 1 1 0 0   |  0h      | 1  11  1  1  0   1   0  | 0x000000 | 0FFFh | 4-я запись - сегмент кода пользовательского уровня
	;   | 0x00   | 1 1 0 0   |  0h      | 1  11  1  0  0   1   0  | 0x000000 | 0FFFh | 5-я запись - сегмент данных пользовательского уровня
	;   | 0x00   | 0 0 0 0   |  0h      | 1  00  0  1  0   0   1  | 0x000000 | 0FFFh | 6-я запись - сегмент данных для задач
	;    ____________________________________________________________________________
	;   НО! Дескриптор в исходном виде так записывать нельзя.
	;   Большинство современных архитектур, таких как x86, используют little-endian.
	;   Поэтому, когда данные записываются в память, порядок байтов будет изменён,
	;   чтобы соответствовать этому стандарту. При этом отдельные биты сохраняют свои позиции,
	;   однако порядок байтов изменяется для правильной интерпретации данных процессором.
	;   |   Limit   |      Base       | Access Byte | Flags + Limit | Base |
	db   000h, 000h,   00h, 00h, 00h,   00000000b,    00000000b,     0x00   ; 1-я запись всегда равна NULL
	db   0FFh, 0FFh,   00h, 00h, 00h,   10011010b,    11001111b,     0x00   ; 2-я запись - сегмент кода ОС
	db   0FFh, 0FFh,   00h, 00h, 00h,   10010010b,    11001111b,     0x00   ; 3-я запись - сегмент данных ОС
	db   0FFh, 0FFh,   00h, 00h, 0Ah,   10010010b,    10000000b,     0x00   ; 4-я запись - сегмент видеопамяти
	;db   0FFh, 0FFh,   00h, 00h, 0Fh,   11111010b,    10000000b,     0x00   ; 5-я запись - сегмент кода пользовательского уровня
	;db   0FFh, 0FFh,   00h, 00h, 0Fh,   11110010b,    10000000b,     0x00   ; 6-я запись - сегмент данных пользовательского уровня

	label GDT_SIZE at $-GDT        ; Создаём переменную для хранения размера GDT
	;===================================

	;===== Данные для регистра GDTR =====
	GDTR_DATA:
	dw GDT_SIZE-1        ; Размер GDT
	dd GDT+10000h        ; Адрес 
	;====================================

;virtual ;теперь, фактически, забиваем пространство до конца сегмента

;rb 10000h-$;

;end virtual

	use32
	org $+10000h ; $ = 53
	ProtectedMode:
		mov ax, 10h
		mov es, ax
		mov ds, ax
		mov fs, ax
		mov ss, ax
		mov esp, 10000h
		mov ax, 18h
		mov gs, ax

	;xor eax, eax
	;mov al, 0xF      ; цвет пикселя
	;mov ebx, 0      ; x-координата
	;mov edx, 0      ; y-координата
   
	;call VIDEO__Fill_Screen

	jmp Next

	jmp $

Next:

;times 512 - ($ - start) db 0